---
title: "Package Quick Start Guide"
author: 
- name: Jiefei Wang
  affiliation: Roswell Park Comprehensive Cancer Center, Buffalo, NY
date: "`r Sys.Date()`"
output:
    BiocStyle::html_document:
        toc: true
        toc_float: true
vignette: >
  %\VignetteIndexEntry{quickStart}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
package: SharedObject
---

```{r setup, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
library("SharedObject")
```
# Introduction
The `SharedObject` package is designed for sharing data across multiple R processes, where all processes can read the data located in the same memory location. This sharing mechanism has the potential to save the memory usage and reduce the overhead of data transmission in the parallel computing. The use of the package arises from many data-science subjects such as high-throughput gene data analysis, in which case a parallel computing is desirable and the data is very large. Blindly calling an export function such as `clusterExport` will duplicate the data for each process and it is obviously unnecessary if the data is just read-only. The `sharedObject` package can share the data without duplications and is able to reduce the time cost. A new set of R APIs called `ALTREP` is used to provide a seamless experience when sharing an object.

# Quick example
We first demonstrate the package with an example. In this example, we create a cluster with 4 cores and share an n-by-n matrix `A`, we use the function `share` to create the shared object `shared_A` and call the function `clusterExport` to export it:

```{r}
library(parallel)
## Initiate the cluster
cl <- makeCluster(1)
## create data
n <- 3
A <- matrix(runif(n^2),n,n)
## create shared object
shared_A <- share(A)
## export the shared object
clusterExport(cl,"shared_A")

stopCluster(cl)
```
As the code shows above, the procedure of exporting a shared object with the other R processes is similar to the procedure of exporting an R object, except that we replace the matrix `A` with a shared object `shared_A`. Notably, there is no different between the matrix `A` and the shared object `shared_A`. The shared object `shared_A` is neither an S3 nor S4 object and its behaviors are exactly the same as the matrix `A`, so there is no need to change the existing code to work with the shared object. We can verify this through
```{r}
## check the data
A
shared_A
## check the properties
attributes(A)
attributes(shared_A)
## check the class
class(A)
class(shared_A)
```
Users can treate the shared object `shared_A` as a matrix and do operations on it as usual. For reducing the unnecessary creation of a shared object, the subset of a shared object is a regular R object. Users can verify this by calling `is.shared`
```{r}
## `shared_A` is a shared object
is.shared(shared_A)

## The subset of `shared_A` is not
is.shared(shared_A[1:2])
```
This behavior, however, can be altered via the argument `sharedSubset`. Therefore, if the shared object `shared_A` is made by `share(A, sharedSubset = TRUE)`, then all the subsets of the object `shared_A` will be shared objects automatically. 

# Supported data types and structures
Currently, the package supports `raw`, `logical`, `integer` and `double` data types. `character` is not supported. Sharing the data structure `atomic`(aka `vector`), `matrix`, `data.frame` and `list` is also available. The function `share` is an S4 generic, developers can define an S4 `share` function to support their own data structures.

Please note that sharing a list object will not sharing the list itself, but sharing each element of the list object instead. Therefore, adding or replace an element on a shared list in the main process will not implicitly change the shared list on the other processes. Users should be cautious about it. Since a data frame is fundamentally a list object, sharing a data frame will follow the same principle as sharing a list. 

When a list consists of sharable and non-sharable objects, `noError` argument can be used in the `share` function to share the sharable elements and keep the non-sharable elements same. Alternatively, the function `tryShare` is a shortcut for `share(..., noError = TRUE)`
```{r}
## the element `a` is sharable and b is not
mydata <- list(a = 1:3, b = letters[1:3])

## expect error if we directly share the object
tryCatch(share(mydata), error = function(e) print(e))

## Use the `noError` argument to suppress the error message
sharedList1 <- share(mydata, noError = TRUE)

## Use the function `tryShare`
## this is equivalent to `share(mydata, noError = TRUE)`
sharedList2 <- tryShare(mydata)

## Only the element `a` is a shared object
is.shared(sharedList1)
```


# Check object class
In order to distinguish a shared object, the package provide `is.shared` function to identify a shared object

```{r}
## Check if an object is a shared object
## This works for both vector and data.frame
is.shared(A)
is.shared(shared_A)
```
For an atomic object, `is.shared` returns a logical value indicating whether the object is a shared object. For a list object, it returns a list of logical values with each element representing the corresponding element in the list object.

There are several properties with the shared object, one can check them via
```{r}
## get a summary report
getSharedObjectProperty(shared_A)

## Internal function to check the properties
## get the individual properties
getCopyOnWrite(shared_A)
getSharedSubset(shared_A)
getSharedCopy(shared_A)
```
Please see the advanced topic to see which properties are changable and how to change them in a proper way.

# Global options
There are some options that can control the default behavior of a shared object, you can view them via
```{r}
getSharedObjectOptions()
```
As beforementioned, the option `sharedSubset` controls whether the subset of a shared object is still a shared object. The option `noError` suppress the error message when the function `share` encounter a non-sharable object and return the same object. We will talk about the options `copyOnWrite` and `sharedCopy` in the advanced section, but for most users these should not be changed. The global setting can be modified via `setSharedObjectOptions`
```{r}
## change the default setting
setSharedObjectOptions(noError = TRUE)
## Check if the change is made
getSharedObjectOptions("noError")
```

# Advanced topic: Copy-On-Write
Because all cores are using the shared object `shared_A` located in the same memory location, a reckless change made on the matrix `shared_A` on one process will immediately be broadcasted to the other process. To prevent users from changing the values of a shared object without awareness, a shared object will duplicate itself if a change of its value is made. Therefore, the code like

```{r}
shared_A2 <- shared_A
shared_A[1,1] <- 10

shared_A
shared_A2
```
will result in a memory dulplication. The matrix `shared_A` is not affected. This default behavior can be overwritten by passing an argument `copyOnWrite` to the function `share`. For example

```{r}
shared_A <- share(A, copyOnWrite=FALSE)
shared_A2 <- shared_A
shared_A[1,1] <- 10

shared_A
shared_A2
```
A change in the matrix `shared_A` cause a change in `shared_A2`. This feature could be potentially useful to return the result from each R process without additional memory allocation, so `shared_A` can be both the initial data and the final result. However, due to the limitation of R, it is possible to change the value of a shared object unexpectly. For example

```{r}
shared_A <- share(A, copyOnWrite = FALSE)
-shared_A
shared_A
```
The above example shows an unexpected result when the copy-on-write feature is off. Simply calling an unary function can change the values of a shared object. Therefore, for the safty of the naive user, the copy-on-write feature is active by default. For the sophisticated R user, the copy-on-write feature of an object can be altered via `setCopyOnwrite` funtion. The old value will be invisibly returned by the function.

```{r}
shared_A <- share(A, copyOnWrite = FALSE)
## Assign shared_A to another object
shared_A2 <- shared_A
## change the value of shared_A
shared_A[1,1] <- 10
## Both shared_A and shared_A2 are affected
shared_A
shared_A2
## Enable copy-on-write
setCopyOnWrite(shared_A, TRUE)
## shared_A is now independent with shared_A2
shared_A[1,2] <- 10
shared_A
shared_A2

## shared_A became a regular R object
is.shared(shared_A)
```
These flexibilities provide us a way to do safe operations during the computation and return the results without memory duplications.

## Warning
If a high-precision value is assigned to a low-precision shared object, An implicit type conversion will be triggered for correctly storing the change. The resulting object would be a regular R object, not a shared object. Therefore, the change will not be broadcasted even if the copy-on-write feature is off. The most common senario is to assign a numeric value to an integer shared object. Users should be caution with the data type that a shared object is using.

# Advanced topic: shared subset and shared copy
The options `sharedSubset` controls whether to create a shared object when subsetting a shared object. `sharedCopy` determines if the duplication of a shared object is still a shared object. For performance consideration, the default settings are `sharedSubset =  FALSE` and `sharedDuplicate=FALSE`, but they can be temporary overwritten via:
```{r}
shared_A <- share(A, sharedSubset = TRUE, sharedCopy = TRUE)
getSharedObjectProperty(shared_A)
```
Please note that `sharedCopy` is only available when `copyOnWrite = TRUE`.

# Session Information
```{r}
sessionInfo()
```




