% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/allGenerics.R, R/share.R
\name{share}
\alias{share}
\alias{share,vector-method}
\alias{share,matrix-method}
\alias{share,data.frame-method}
\alias{share,list-method}
\alias{share,ANY-method}
\alias{share,character-method}
\alias{tryShare}
\title{Create a shared object}
\usage{
share(x, ...)

\S4method{share}{ANY}(x, autoS4Conversion, ...)

\S4method{share}{character}(x, mustWork, ...)

\S4method{share}{vector}(x, ...)

\S4method{share}{matrix}(x, ...)

\S4method{share}{list}(x, ...)

tryShare(x, ...)
}
\arguments{
\item{x}{An R object that you want to shared. The supported data types are
\code{raw}, \code{logical}, \code{integer} and \code{real}. \code{character} cannot be shared.}

\item{...}{Additional parameters that can be passed to the shared object, see below.}

\item{autoS4Conversion}{Whether to use the automatic conversion method for
an S4 object when there is no \code{share} method defined
for the signiture \code{class(x)}, see details.}

\item{mustWork}{Whether to throw an error if \code{x} is not a sharable object(e.g. Character).}

\item{copyOnWrite, sharedSubset, sharedCopy}{The parameters controlling the behavior of the shared object,
see details.}
}
\value{
A shared object
}
\description{
This function will create a shared object in the shared memory for the function
argument \code{x} and return a shared object if the object can be shared.
There is no duplication of the shared object when a shared object is
exported to the other processes.
\code{tryShare} is equivalent to \code{share} with the argument \code{mustWork = FALSE}.
}
\details{
The function returns a shared object corresponding to the argument \code{x} if it
is sharable. An error will be given if the argument \code{x} is not sharable. specifying
\code{mustWork = FALSE} will suppress the error. This feature is useful when sharing a list
object that consists of both sharable and non-sharable objects. Alternatively,
the \code{tryShare} function can be used and it is equivalent to the function
\code{share} with the argument \code{mustWork = FALSE}.

\strong{Supported types}

The function supports sharing \code{raw},\code{logical} ,\code{integer}, \code{double} data types.
When the argument \code{x} is an atomic object(e.g vector, matrix),
the function will create an ALTREP object to replace it.
When \code{x} is a list, each column of \code{x} will be replaced by an ALTREP object.
The function \code{share} is an S4 generic, Package developers can provide their own
shared object by defining an S4 \code{share} function.

\strong{Behavior control}

In the R level, the behaviors of an ALTREP object is exactly the same as an atomic object
but the data of an ALTREP object is allocated in the shared memory space. Therefore an
ALTREP object can be easily exported to the other R processes without dulplicating the
data, which reduces the memory usage and the overhead of data transmission.

The behavior of a shared object can be controlled through three parameters:
\code{copyOnWrite}, \code{sharedSubset} and \code{sharedCopy}.

\code{copyOnWrite} determines Whether a new R object need to be allocated when the
shared object is changed. The default value is \code{TRUE}, but can be altered by passing
an argument \code{copyOnWrite = FALSE} to the function.

Please note that the no-copy-on-write feature is not fully supported by R. When
\code{copyOnWrite} is \code{FALSE}, a shared object might not behaves as user expects.
Please refer to the example code to see the exceptions.

\code{sharedSubset} determines whether the subset of a shared object is still a shared object.
The default value is \code{TRUE}, and can be changed by passing \code{sharedSubset = FALSE}
to the function

At the time this documentation is being written, The shared subset feature will
cause an unnecessary memory duplication in R studio. Therefore, for the performance
consideration, it is better to turn the feature off when using R studio.

\code{sharedCopy} determines whether the object is still a shared object after a
duplication. If \code{copyOnWrite} is \code{FALSE}, this feature is off since the duplication
cannot be triggered. In current version (R 3.6), an object will be duplicated four times
for creating a shared object and lead to a serious performance problem. Therefore,
the default value is \code{FALSE}, user can alter it by passing \code{sharedCopy = FALSE}
to the function.

\strong{Default S4 share function}
If the argument \code{x} is an S4 object and its class is not supported
by the \code{share} function. A default \code{share} function can be used by specifying
\code{autoS4Conversion = TRUE}. The default method will loop over and share
all slots for the object \code{x}. No error will be given if a slot
of \code{x} is not sharable. Please be aware that this method may have an
unexpected consequence(e.g. a C pointer is linked with a slot data of \code{x}).
It only serves as a backup method. Most bioconductor fundamental classes are supported in
\code{SharedObjectUltility}, if you find the class of \code{x} is not supported by
\code{SharedObjectUltility} and is important for Bioconductor users, please feel free to ask
for the new feature at
\href{https://github.com/Jiefei-Wang/SharedObjectUtility/issues}{GitHub}.
}
\examples{
## For vector
x <- runif(10)
so <- share(x)
x
so

## For matrix
x <- matrix(runif(10), 2, 5)
so <- share(x)
x
so

## For data frame
x <- as.data.frame(matrix(runif(10), 2, 5))
so <- share(x)
x
so

## export the object
library(parallel)
cl <- makeCluster(1)
clusterExport(cl, "so")
## check the exported object in the other process
clusterEvalQ(cl, so)

## close the connection
stopCluster(cl)

## Copy-on-write
## This is the default setting
x <- runif(10)
so1 <- share(x, copyOnWrite = TRUE)
so2 <- so1
so2[1] <- 10
## so1 is unchanged since copy-on-write feature is on.
so1
so2

## No-copy-on-write
so1 <- share(x, copyOnWrite = FALSE)
so2 <- so1
so2[1] <- 10
#so1 is changed
so1
so2

## Flaw of no-copy-on-write
## The following code changes the value of so1, highly unexpected! Please use with caution!
-so1
so1
## The reason is that the minus function trys to dulplicate so1 object,
## but the dulplicate function will return so1 itself, so the value in so1 also get changed.

}
